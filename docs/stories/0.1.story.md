# Story 0.1: Universal Provider Interface & Named Sessions Foundation

## Status
**Approved - Epic 0 Foundation Story**

## Implementation Source (10000% Working Code)
- Canonical reference: `/Users/jasonk/Development/the_maestro/source/codex`
- All flows, interfaces, and examples in this story MUST be adapted from the above source to guarantee 10000% working behavior.

## Plan Alignment
- This story follows `docs/prd/EMERGENCY-COURSE-CORRECT-PRD-gpt.md` (GPT variant). Ensure acceptance criteria and tasks align with the PRD’s corrective additions and architecture clarifications.

## Story
**As the system,**
**I want** a universal provider interface with dynamic module resolution and support for named authentication sessions,
**so that** I can provide a consistent API across all LLM providers while supporting multiple concurrent authentication sessions per provider/auth_type combination.

## Acceptance Criteria

### AC-TYPES: Types/Specs/Structs Required
1. All public functions include explicit `@spec` annotations with concrete types (no `term()` for public APIs).
2. Any non-trivial map used across module boundaries is defined as a dedicated struct with `@typedoc`, `@type t`, and `@enforce_keys` where appropriate.
3. Provider responses, session descriptors, capability maps, and streaming messages are represented by typed structs rather than ad-hoc maps.
4. Type aliases are added for common domain types (e.g., `provider()`, `auth_type()`, `session_id()`) and reused across modules.
5. Credo, Dialyzer, and compiler warnings must be clean; typespecs should not use overly-broad unions unless justified in docs.

### AC-1: Universal Provider Interface Module
1. The `TheMaestro.Provider` module provides a single entry point for all provider operations across all LLM providers.
2. All provider-specific operations are accessible through standardized function signatures with comprehensive @spec declarations.
3. The interface supports all authentication types (OAuth, API Key) and all provider capabilities (streaming, model listing, context management).
4. Dynamic module resolution enables adding new providers without modifying the core interface code.

### AC-2: Named Authentication Sessions Support
1. The `saved_authentications` schema supports multiple concurrent sessions per provider/auth_type combination.
2. Sessions are identified by user-defined names (e.g., "work_claude", "personal_gpt", "dev_gemini").
3. Session lifecycle management includes creation, validation, cleanup, and expiration handling.
4. Migration from existing single-session-per-provider system preserves all current authentication data.

### AC-3: Provider Behavior System
1. All provider implementations conform to standardized behaviors for OAuth, API Key, Streaming, and Model operations.
2. Behavior compliance validation ensures consistent implementation across all providers.
3. Provider capabilities are discoverable through the interface (supported auth types, features, limitations).
4. New providers integrate through behavior implementation without core system changes.

### AC-4: Dynamic Module Resolution System
1. Provider modules are resolved dynamically based on provider atoms and operation types.
2. Module path generation follows consistent patterns (e.g., `:anthropic + :oauth → TheMaestro.Providers.Anthropic.OAuth`).
3. Missing or invalid providers are handled gracefully with appropriate error responses.
4. Provider registration and discovery happen automatically without manual configuration.

## Tasks / Subtasks

### Task 1: Schema Migration for Named Sessions (AC-2)
**Duration:** 1 day  
**Priority:** CRITICAL - Foundational requirement for all other Epic 0 stories

- [ ] **Task 1.1: Database Schema Migration** (AC-2)
  - [ ] **MANDATORY: Create migration adding `name` field to saved_authentications**
    - [ ] Add `name :string, null: false` field to saved_authentications table
    - [ ] Change unique constraint from `[:provider, :auth_type]` to `[:provider, :auth_type, :name]`
    - [ ] Add index on `[:provider, :auth_type, :name]` for performance
    - [ ] Include rollback strategy for safe migration
  - [ ] **MANDATORY: Create backfill migration for existing data**
    - [ ] Set `name = "default_#{provider}_#{auth_type}"` for all existing records
    - [ ] Validate no data loss during migration process
    - [ ] Add validation to ensure all records have non-empty names
    - [ ] Create comprehensive migration tests

- [ ] **Task 1.2: SavedAuthentication Module Updates** (AC-2)
  - [ ] **MANDATORY: Update schema definition with new field**
    - [ ] Add `field :name, :string` to schema
    - [ ] Update changeset to require and validate name field
    - [ ] Add name format validation (alphanumeric, underscore, hyphen only)
    - [ ] Add name length validation (3-50 characters)
  - [ ] **MANDATORY: Update existing functions for named sessions**
    - [ ] Modify `get_by_provider/2` to `get_by_provider_and_name/3`
    - [ ] Update `upsert/3` to handle name parameter
    - [ ] Add `list_by_provider/1` for discovering existing sessions
    - [ ] Add `delete_by_name/3` for named session cleanup
  - [ ] **MANDATORY: Comprehensive @spec declarations for all functions**
    - [ ] `@spec create_named_session(provider(), auth_type(), String.t(), map()) :: {:ok, t()} | {:error, term()}`
    - [ ] `@spec get_named_session(provider(), auth_type(), String.t()) :: t() | nil`
    - [ ] `@spec list_provider_sessions(provider()) :: [t()]`
    - [ ] `@spec delete_named_session(provider(), auth_type(), String.t()) :: :ok | {:error, term()}`

### Task 2: Universal Provider Interface Implementation (AC-1)
**Duration:** 2 days  
**Priority:** CRITICAL - Core interface for all provider operations

- [x] **Task 2.1: Core Provider Module Creation** (AC-1)
  - [ ] **MANDATORY: Create `lib/the_maestro/providers/provider.ex`**
    - [x] **MANDATORY: Complete @spec declarations for all interface functions:**
      ```elixir
      @spec create_session(provider(), auth_type(), keyword()) :: {:ok, session_id()} | {:error, term()}
      @spec delete_session(provider(), auth_type(), session_id()) :: :ok | {:error, term()}
      @spec refresh_tokens(provider(), session_id()) :: {:ok, tokens()} | {:error, term()}
      @spec list_models(provider(), auth_type(), session_id()) :: {:ok, [model()]} | {:error, term()}
      @spec stream_chat(provider(), session_id(), messages(), keyword()) :: {:ok, stream()} | {:error, term()}
      @spec list_context_chunks(provider(), session_id(), context_id()) :: {:ok, [chunk()]} | {:error, term()}
      @spec delete_context_chunk(provider(), session_id(), context_id(), chunk_id()) :: :ok | {:error, term()}
      @spec list_providers() :: [provider()]
      @spec provider_capabilities(provider()) :: %{auth_types: [auth_type()], features: [feature()]}
      ```
    - [x] **MANDATORY: Define comprehensive type specifications**
      ```elixir
      @type provider() :: :anthropic | :openai | :gemini
      @type auth_type() :: :oauth | :api_key
      @type session_id() :: String.t()
      @type tokens() :: %{access_token: String.t(), refresh_token: String.t(), expires_at: DateTime.t()}
      @type model() :: %{id: String.t(), name: String.t(), capabilities: [String.t()]}
      @type messages() :: [%{role: String.t(), content: String.t()}]
      @type chunk() :: %{id: String.t(), content: String.t(), metadata: map()}
      @type feature() :: :streaming | :model_listing | :context_management | :token_refresh
      ```
    - [x] **MANDATORY: Implement interface functions with dynamic module resolution**
      - [x] All functions delegate to appropriate provider modules via resolver
      - [x] Comprehensive error handling for missing providers or invalid parameters
      - [x] Consistent error response format across all operations
      - [ ] Session name validation and normalization

- [ ] **Task 2.2: Provider Discovery and Capabilities** (AC-1, AC-4)
  - [ ] **MANDATORY: Implement `list_providers/0` function**
    - [x] Discover available providers by scanning module paths (static list for now)
    - [ ] Return list of provider atoms with basic metadata
    - [ ] Cache results for performance optimization
    - [ ] Handle provider loading failures gracefully
  - [ ] **MANDATORY: Implement `provider_capabilities/1` function**
    - [x] Query provider modules for supported auth types (introspection-based default)
    - [x] Discover available features (streaming, model listing, etc.)
    - [x] Return structured capability map for each provider (Capabilities struct)
    - [ ] Include provider-specific limitations and requirements

### Task 3: Dynamic Module Resolution System (AC-4)
**Duration:** 1 day  
**Priority:** HIGH - Enables extensible provider architecture

- [ ] **Task 3.1: Provider Resolver Implementation** (AC-4)
  - [ ] **MANDATORY: Create `lib/the_maestro/providers/resolver.ex`**
    - [ ] **MANDATORY: Complete @spec declarations for resolution functions:**
      ```elixir
      @spec resolve_module(provider(), operation()) :: {:ok, module()} | {:error, :module_not_found}
      @spec build_module_path(provider(), operation()) :: module()
      @spec validate_provider_compliance(module()) :: :ok | {:error, [String.t()]}
      ```
    - [ ] **MANDATORY: Implement module path generation algorithm**
      ```elixir
      # Examples of dynamic resolution patterns:
      resolve_module(:anthropic, :oauth) -> TheMaestro.Providers.Anthropic.OAuth
      resolve_module(:openai, :streaming) -> TheMaestro.Providers.OpenAI.Streaming
      resolve_module(:gemini, :models) -> TheMaestro.Providers.Gemini.Models
      ```
    - [ ] **MANDATORY: Module existence validation with Code.ensure_loaded?/1**
    - [ ] **MANDATORY: Error handling for missing or invalid modules**

- [ ] **Task 3.2: Provider Registration System** (AC-4)  
  - [ ] **MANDATORY: Automatic provider discovery on application start**
    - [ ] Scan provider directory for valid provider modules
    - [ ] Validate behavior compliance for discovered providers
    - [ ] Cache provider registry for runtime performance
    - [ ] Log discovered providers and their capabilities during startup
  - [ ] **MANDATORY: Provider validation and compliance checking**
    - [ ] Verify all required behaviors are implemented
    - [ ] Validate function signatures match behavior specifications
    - [ ] Check for required configuration and dependencies
    - [ ] Report compliance issues with detailed error messages

### Task 4: Provider Behavior Definitions (AC-3)
**Duration:** 1 day  
**Priority:** HIGH - Ensures consistent provider implementation

- [x] **Task 4.1: OAuth Provider Behavior** (AC-3)
  - [ ] **MANDATORY: Create `lib/the_maestro/providers/behaviors/oauth_provider.ex`**
    - [ ] **MANDATORY: Define OAuth behavior callbacks:**
      ```elixir
      @callback generate_auth_url(session_name :: String.t(), opts :: keyword()) :: 
        {:ok, {auth_url :: String.t(), pkce_params :: map()}} | {:error, term()}
      @callback exchange_code(auth_code :: String.t(), pkce_params :: map(), session_name :: String.t()) ::
        {:ok, tokens :: map()} | {:error, term()}
      @callback refresh_token(refresh_token :: String.t(), session_name :: String.t()) ::
        {:ok, tokens :: map()} | {:error, term()}
      @callback extract_api_credentials(tokens :: map(), session_name :: String.t()) ::
        {:ok, credentials :: map()} | {:error, term()}
      ```
    - [ ] **MANDATORY: OAuth configuration structure definition**
    - [ ] **MANDATORY: PKCE parameter validation and generation helpers**
    - [ ] **MANDATORY: Token response parsing and validation utilities**

- [x] **Task 4.2: API Key Provider Behavior** (AC-3)
  - [ ] **MANDATORY: Create `lib/the_maestro/providers/behaviors/api_key_provider.ex`**
    - [ ] **MANDATORY: Define API key behavior callbacks:**
      ```elixir
      @callback validate_api_key(api_key :: String.t()) :: :ok | {:error, term()}
      @callback create_client(api_key :: String.t(), opts :: keyword()) :: {:ok, client :: term()} | {:error, term()}
      @callback test_connection(client :: term()) :: :ok | {:error, term()}
      ```
    - [ ] **MANDATORY: API key format validation utilities**
    - [ ] **MANDATORY: Connection testing and health check patterns**

- [x] **Task 4.3: Streaming and Model Provider Behaviors** (AC-3)
  - [ ] **MANDATORY: Create `lib/the_maestro/providers/behaviors/streaming_provider.ex`**
    - [ ] **MANDATORY: Define streaming behavior callbacks:**
      ```elixir
      @callback stream_chat(client :: term(), messages :: [map()], opts :: keyword()) ::
        {:ok, stream :: Enumerable.t()} | {:error, term()}
      @callback parse_stream_event(event :: map(), state :: map()) :: 
        {messages :: [map()], new_state :: map()}
      ```
  - [ ] **MANDATORY: Create `lib/the_maestro/providers/behaviors/model_provider.ex`**
    - [ ] **MANDATORY: Define model listing behavior callbacks:**
      ```elixir
      @callback list_models(client :: term()) :: {:ok, [model()]} | {:error, term()}
      @callback get_model_info(client :: term(), model_id :: String.t()) ::
        {:ok, model_info :: map()} | {:error, term()}
      ```

### Task 5: Integration Testing and Validation (AC-1, AC-2, AC-3, AC-4)
**Duration:** 1 day  
**Priority:** HIGH - Ensures foundation stability

- [ ] **Task 5.1: Universal Interface Testing** (AC-1)
  - [ ] **MANDATORY: Create comprehensive test suite `test/the_maestro/providers/provider_test.exs`**
    - [ ] **MANDATORY: Test all interface functions with mock providers**
      - [ ] `create_session/3` with valid and invalid parameters
      - [ ] `delete_session/3` with existing and non-existent sessions
      - [ ] `list_models/3` with different auth types and providers
      - [ ] `stream_chat/4` with message validation and error handling
      - [ ] Provider discovery and capability detection
    - [ ] **MANDATORY: Error handling validation**
      - [ ] Invalid provider atoms return appropriate errors
      - [ ] Missing modules handled gracefully
      - [ ] Parameter validation with clear error messages
      - [ ] Timeout handling for provider operations

- [ ] **Task 5.2: Named Sessions Integration Testing** (AC-2)
  - [ ] **MANDATORY: Create named sessions test suite `test/the_maestro/providers/named_sessions_test.exs`**
    - [ ] **MANDATORY: Test session lifecycle management**
      - [ ] Multiple sessions per provider/auth_type combination
      - [ ] Session name uniqueness validation
      - [ ] Session cleanup and expiration handling
      - [ ] Migration from existing single sessions
    - [ ] **MANDATORY: Database integration testing**
      - [ ] Schema migration validation with sample data
      - [ ] Constraint enforcement testing
      - [ ] Performance testing with multiple sessions
      - [ ] Rollback testing for migration safety

- [ ] **Task 5.3: Provider Behavior Compliance Testing** (AC-3)
  - [ ] **MANDATORY: Create behavior compliance test suite**
    - [ ] **MANDATORY: Mock provider implementations for testing**
      - [ ] Create test providers implementing all behaviors
      - [ ] Validate behavior compliance checking works correctly
      - [ ] Test error handling for non-compliant providers
      - [ ] Verify provider discovery excludes invalid implementations
    - [ ] **MANDATORY: Integration with existing streaming architecture**
      - [ ] Validate new behavior system works with existing handlers
      - [ ] Test streaming provider behavior with real stream data
      - [ ] Verify model provider behavior with sample model data
      - [ ] Ensure OAuth/API key behaviors work with existing auth system

## Dev Notes

### Architecture Context

**Universal Provider Interface Design:**
[Source: GPT PRD Universal Provider Architecture Specification]
The universal provider interface serves as a facade pattern that provides consistent access to all LLM providers while maintaining provider-specific optimizations. This design enables:

1. **Provider Abstraction**: Single entry point eliminates need for provider-specific integration code
2. **Dynamic Extensibility**: New providers integrate without modifying existing application code  
3. **Session Management**: Named sessions enable multiple concurrent authentications per provider
4. **Behavior Consistency**: All providers implement standardized interfaces for predictable operation

**Named Sessions Architecture:**
[Source: GPT PRD Named Sessions — Schema Change (MANDATORY)]
Named sessions enable multiple concurrent authentication contexts per provider/auth_type combination:

1. **Schema Enhancement**: Single field addition with composite unique constraint
2. **Backwards Compatibility**: Migration preserves existing authentication data
3. **User Experience**: Intuitive session naming (e.g., "work_claude", "personal_gpt")  
4. **Session Lifecycle**: Complete management from creation through cleanup

### Database Migration Strategy

**Migration Safety Protocol:**
```elixir
# Migration implementation pattern
defmodule TheMaestro.Repo.Migrations.AddNamedSessions do
  use Ecto.Migration
  
  def up do
    alter table(:saved_authentications) do
      add :name, :string, null: false, default: "default"
    end
    
    # Backfill existing records
    execute """
    UPDATE saved_authentications 
    SET name = 'default_' || provider || '_' || auth_type 
    WHERE name = 'default'
    """
    
    # Remove default and add constraints
    alter table(:saved_authentications) do
      modify :name, :string, null: false
    end
    
    drop_if_exists unique_index(:saved_authentications, [:provider, :auth_type])
    create unique_index(:saved_authentications, [:provider, :auth_type, :name])
  end
  
  def down do
    # Safe rollback implementation
    drop_if_exists unique_index(:saved_authentications, [:provider, :auth_type, :name])
    create unique_index(:saved_authentications, [:provider, :auth_type])
    
    alter table(:saved_authentications) do
      remove :name
    end
  end
end
```

### Provider Interface Implementation Patterns

**Dynamic Module Resolution Algorithm:**
```elixir
defmodule TheMaestro.Provider.Resolver do
  @provider_base_module TheMaestro.Providers
  
  def resolve_module(provider, operation) do
    module_name = build_module_path(provider, operation)
    
    case Code.ensure_loaded?(module_name) do
      true -> 
        if validate_behavior_compliance(module_name) do
          {:ok, module_name}
        else
          {:error, :behavior_non_compliant}
        end
      false -> 
        {:error, :module_not_found}
    end
  end
  
  defp build_module_path(provider, operation) do
    provider_module = provider |> Atom.to_string() |> String.capitalize()
    operation_module = operation |> Atom.to_string() |> String.capitalize()
    
    Module.concat([@provider_base_module, provider_module, operation_module])
  end
end
```

### Integration with Existing Architecture

**Preservation of Current Functionality:**
[Source: Analysis of existing TheMaestro architecture]
The universal interface builds upon existing strengths while addressing architectural gaps:

1. **Streaming Integration**: Leverages existing `TheMaestro.Streaming` architecture without modification
2. **Authentication Preservation**: Extends existing `SavedAuthentication` schema with minimal changes
3. **Configuration Compatibility**: Works with current configuration patterns during transition
4. **Testing Framework**: Builds upon established testing patterns and mock strategies

**Backwards Compatibility During Migration:**
During Epic 0 implementation, the following compatibility approach ensures continuous operation:
1. **Dual API Support**: Existing modules continue working alongside new interface
2. **Gradual Migration**: Internal calls migrate incrementally to new interface
3. **Deprecation Warnings**: Clear migration path with @deprecated annotations
4. **Rollback Safety**: Complete rollback capability at each implementation stage

### Security Considerations

**Session Security Implementation:**
[Source: docs/architecture/security-architecture.md analysis]
Named sessions maintain and enhance existing security posture:

1. **Encryption Preservation**: All session data remains encrypted using existing ClakEcto implementation
2. **Session Isolation**: Named sessions provide improved isolation between authentication contexts
3. **Access Control**: Session names provide additional access control dimension for multi-user scenarios
4. **Audit Trail**: Enhanced tracking of authentication session usage and lifecycle

### Testing Strategy

**Comprehensive Testing Approach:**
[Source: docs/standards/testing-strategies.md and existing test patterns]

**Unit Testing Requirements:**
1. **Interface Validation**: All @spec declarations validated with comprehensive parameter testing
2. **Behavior Compliance**: Provider behavior implementation validated through mock providers
3. **Error Handling**: All error conditions tested with appropriate error message validation
4. **Session Management**: Complete session lifecycle testing with edge case coverage

**Integration Testing Requirements:**
1. **Database Integration**: Schema migration testing with existing data preservation
2. **Provider Discovery**: Automatic provider registration and discovery validation
3. **Backwards Compatibility**: Existing functionality preservation during transition
4. **Performance Testing**: Session management performance with multiple concurrent sessions

**Manual Testing Protocol:**
Following established manual testing patterns for OAuth validation:
1. **Session Creation**: Manual validation of named session creation across providers
2. **Session Management**: Multi-session scenarios with real provider authentication
3. **Migration Validation**: Real-world migration testing with existing authentication data
4. **Provider Discovery**: Manual validation of automatic provider discovery and registration

### Quality Gates

**Implementation Quality Standards:**
1. **Code Quality**: All code passes `mix format` and `mix credo --strict`
2. **Documentation**: Complete @spec declarations and comprehensive module documentation
3. **Test Coverage**: >90% test coverage for all new modules and functions
4. **Integration Testing**: All integration scenarios validated with existing architecture
5. **Migration Safety**: Zero data loss validation for schema migration

**Performance Requirements:**
1. **Interface Performance**: <5ms overhead for provider interface calls
2. **Session Lookup**: <2ms for named session retrieval from database
3. **Provider Discovery**: <100ms for complete provider discovery and registration
4. **Memory Usage**: <10MB additional memory for provider registry and interface

### File Structure and Organization

**Files to Create:**
```
lib/the_maestro/providers/
├── provider.ex                    # Universal interface module
├── resolver.ex                    # Dynamic module resolution
├── behaviors/
│   ├── oauth_provider.ex          # OAuth behavior definition
│   ├── api_key_provider.ex        # API key behavior definition
│   ├── streaming_provider.ex      # Streaming behavior definition
│   └── model_provider.ex          # Model listing behavior definition
```

**Migration Files:**
```
priv/repo/migrations/
├── YYYYMMDDHHMMSS_add_named_sessions.exs
├── YYYYMMDDHHMMSS_backfill_session_names.exs
└── YYYYMMDDHHMMSS_add_session_constraints.exs
```

**Test Files:**
```
test/the_maestro/providers/
├── provider_test.exs              # Universal interface tests
├── resolver_test.exs              # Module resolution tests
├── named_sessions_test.exs        # Named session functionality
├── behaviors/
│   ├── oauth_provider_test.exs    # OAuth behavior tests
│   ├── api_key_provider_test.exs  # API key behavior tests
│   ├── streaming_provider_test.exs # Streaming behavior tests
│   └── model_provider_test.exs    # Model behavior tests
└── integration/
    ├── provider_discovery_test.exs # Provider registration tests
    └── migration_test.exs          # Schema migration tests
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-30 | 1.0 | Initial Epic 0 Story 0.1 creation with comprehensive universal provider interface and named sessions foundation | BMad Master |
| 2025-08-31 | 1.1 | Implement universal provider scaffolding: added TheMaestro.Provider, provider behaviours (auth/streaming/models), typed streaming structs and shared types; created provider stubs for OpenAI/Anthropic/Gemini. Note: resolver integrated into Provider module; capabilities use introspection-based defaults. | James (dev) |

## File List

- lib/the_maestro/provider.ex
- lib/the_maestro/types.ex
- lib/the_maestro/streaming/message.ex
- lib/the_maestro/streaming/function_call.ex
- lib/the_maestro/providers/behaviours/auth.ex
- lib/the_maestro/providers/behaviours/streaming.ex
- lib/the_maestro/providers/behaviours/models.ex
- lib/the_maestro/providers/capabilities.ex
- lib/the_maestro/providers/openai/oauth.ex (stub)
- lib/the_maestro/providers/openai/api_key.ex (stub)
- lib/the_maestro/providers/openai/streaming.ex (stub)
- lib/the_maestro/providers/openai/models.ex (stub)
- lib/the_maestro/providers/anthropic/oauth.ex (stub)
- lib/the_maestro/providers/anthropic/api_key.ex (stub)
- lib/the_maestro/providers/anthropic/streaming.ex (stub)
- lib/the_maestro/providers/anthropic/models.ex (stub)
- lib/the_maestro/providers/gemini/oauth.ex (stub)
- lib/the_maestro/providers/gemini/api_key.ex (stub)
- lib/the_maestro/providers/gemini/streaming.ex (stub)
- lib/the_maestro/providers/gemini/models.ex (stub)
- test/the_maestro/provider_test.exs

## QA Results

*To be populated by the QA Agent with results from QA review of the completed story implementation*
