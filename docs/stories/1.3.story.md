# Story 1.3: Anthropic OAuth - URL Generation & Token Exchange

## Status
Approved

## Story
**As the system,**
**I want** to generate an Anthropic OAuth 2.0 authorization URL and handle the token exchange when a user provides the authorization code,
**so that** I can establish authenticated communication with the Anthropic API using OAuth credentials for AI-powered agent interactions.

## Acceptance Criteria

1. The `LLMOrchestrator.Auth` module can generate a valid Anthropic OAuth 2.0 authorization URL.

2. The module can accept an authorization code and exchange it for an `access_token` and `refresh_token` from Anthropic's token endpoint.

## Tasks / Subtasks

- [ ] **Task 1: Research and validate llxprt OAuth implementation patterns** (AC: 1, 2)
  - [ ] Extract exact Anthropic OAuth configuration from llxprt-code source
  - [ ] Document required OAuth parameters, endpoints, and PKCE implementation
  - [ ] Validate OAuth flow requirements and error handling patterns

- [ ] **Task 2: Create OAuth configuration structs and types** (AC: 1, 2)
  - [ ] Create `AnthropicOAuthConfig` struct with exact llxprt configuration values
  - [ ] Create `OAuthToken` struct matching llxprt token format
  - [ ] Create `DeviceCodeResponse` struct for simulated device flow response
  - [ ] Create `PKCEParams` struct for PKCE code challenge/verifier pairs
  - [ ] Add comprehensive type specifications for all OAuth data structures
  - [ ] Add `@type` and `@spec` declarations for all structs and functions
  - [ ] Embed all simple structs in main `auth.ex` module per Phoenix conventions

- [ ] **Task 3: Create `TheMaestro.Auth` module** (AC: 1)
  - [ ] Create new auth module with OAuth URL generation function
  - [ ] Implement PKCE (Proof Key for Code Exchange) generation using S256 method
  - [ ] Generate OAuth authorization URL with EXACT llxprt parameter order
  - [ ] Use exact llxprt client_id, endpoints, scopes, and redirect_uri values
  - [ ] Add complete `@spec` declarations for all public functions:
    - [ ] `@spec generate_oauth_url() :: {:ok, {String.t(), PKCEParams.t()}} | {:error, term()}`
    - [ ] `@spec exchange_code_for_tokens(String.t(), PKCEParams.t()) :: {:ok, OAuthToken.t()} | {:error, term()}`
    - [ ] `@spec generate_pkce_params() :: PKCEParams.t()`

- [ ] **Task 4: Implement authorization code exchange** (AC: 2)
  - [ ] Create token exchange function accepting authorization code from user input
  - [ ] Send JSON request (NOT form-encoded) to Anthropic token endpoint
  - [ ] Handle code#state format parsing from user input
  - [ ] Map Anthropic token response to standardized OAuthToken struct
  - [ ] Implement proper error handling for invalid codes and network failures

- [ ] **Task 5: Integrate with existing HTTP client infrastructure** (AC: 1, 2)
  - [ ] Use existing Tesla + Finch HTTP client for OAuth requests
  - [ ] Configure appropriate timeouts and retry logic for OAuth endpoints
  - [ ] Ensure secure handling of OAuth credentials in HTTP requests
  - [ ] Add proper logging without exposing sensitive OAuth data

- [ ] **Task 6: Write comprehensive tests** (AC: 1, 2)
  - [ ] Test OAuth URL generation with correct parameter order and values
  - [ ] Test PKCE generation and validation
  - [ ] Test authorization code exchange with mock responses
  - [ ] Test error handling for invalid codes, network failures, and malformed responses
  - [ ] **IMPERATIVE: Add browser-mcp OAuth flow integration test**
    - [ ] Use browser-mcp to navigate to generated OAuth URL
    - [ ] Automate OAuth authorization flow in real browser
    - [ ] Extract authorization code from callback
    - [ ] Complete token exchange handshake with extracted code
    - [ ] Validate end-to-end OAuth flow with real Anthropic endpoints

- [ ] **Task 7: Update configuration and documentation** (AC: All)
  - [ ] Add OAuth configuration to runtime.exs with environment variable loading
  - [ ] Document OAuth setup process and user workflow
  - [ ] Add code examples for OAuth authentication usage
  - [ ] Update type specifications and module documentation

## Dev Notes

### Previous Story Context
[Source: Story 1.2 completion notes]
Story 1.2 established Anthropic API Key authentication with Tesla + Finch HTTP client infrastructure. The `TheMaestro.Providers.Client` module exists with `build_client/1` function supporting API key authentication for Anthropic provider. The HTTP client infrastructure, configuration system, and provider patterns are already in place.

**Key infrastructure already available:**
- Tesla dependency (~> 1.11) with Finch adapter integration
- Finch connection pools configured for all providers including :anthropic_finch
- Environment-specific configuration system (dev.exs, test.exs, prod.exs, runtime.exs)
- Provider configuration pattern with secure credential loading

### LLXPRT OAuth Implementation Analysis
[Source: /Users/jasonk/Development/the_maestro/source/llxprt-code analysis]

**CRITICAL: Must copy llxprt implementation EXACTLY - no variations allowed.**

#### Exact Configuration Values (from llxprt anthropic-device-flow.ts)
```elixir
# EXACT values from llxprt - DO NOT MODIFY
client_id: "9d1c250a-e61b-44d9-88ed-5944d1962f5e"
authorization_endpoint: "https://claude.ai/oauth/authorize"
token_endpoint: "https://console.anthropic.com/v1/oauth/token"
redirect_uri: "https://console.anthropic.com/oauth/code/callback"
scopes: ["org:create_api_key", "user:profile", "user:inference"]
```

#### OAuth URL Generation (EXACT Parameter Order)
[Source: anthropic-device-flow.ts lines 74-84]
**CRITICAL: Parameter order matters - must match llxprt exactly:**
1. `code: "true"`
2. `client_id: "9d1c250a-e61b-44d9-88ed-5944d1962f5e"`
3. `response_type: "code"`
4. `redirect_uri: "https://console.anthropic.com/oauth/code/callback"`
5. `scope: "org:create_api_key user:profile user:inference"`
6. `code_challenge: <generated_challenge>`
7. `code_challenge_method: "S256"`
8. `state: <code_verifier>` (llxprt uses verifier as state)

#### PKCE Implementation (Exact S256 Method)
[Source: anthropic-device-flow.ts lines 45-60]
- Generate 32-byte random code_verifier using :crypto.strong_rand_bytes/1
- Base64URL encode the verifier
- Create code_challenge using SHA256 hash of verifier, Base64URL encoded
- Use code_verifier as state parameter (llxprt pattern)

#### Token Exchange Request Format
[Source: anthropic-device-flow.ts lines 124-141]
**CRITICAL: Must send JSON request body, NOT form-encoded**
```elixir
# Request headers
headers = [
  {"content-type", "application/json"} # JSON, not form-encoded!
]

# Request body (JSON format)
request_body = %{
  "grant_type" => "authorization_code",
  "code" => auth_code, # From user input
  "state" => state_from_response, # Extracted from user input
  "client_id" => "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
  "redirect_uri" => "https://console.anthropic.com/oauth/code/callback",
  "code_verifier" => stored_code_verifier
}
```

#### User Code Input Format
[Source: anthropic-device-flow.ts lines 110-112]
User provides code in format: `code#state`
- Split on '#' character
- Extract authorization code (first part)
- Extract state (second part, or use stored state as fallback)

### Required Struct Definitions
[Source: llxprt types.ts and analysis requirements]

#### AnthropicOAuthConfig Struct
```elixir
defmodule TheMaestro.Auth.AnthropicOAuthConfig do
  @moduledoc """
  Configuration structure for Anthropic OAuth 2.0 authentication
  Matches llxprt configuration exactly
  """
  
  @type t :: %__MODULE__{
    client_id: String.t(),
    authorization_endpoint: String.t(),
    token_endpoint: String.t(),
    redirect_uri: String.t(),
    scopes: [String.t()]
  }
  
  defstruct [
    client_id: "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
    authorization_endpoint: "https://claude.ai/oauth/authorize",
    token_endpoint: "https://console.anthropic.com/v1/oauth/token",
    redirect_uri: "https://console.anthropic.com/oauth/code/callback",
    scopes: ["org:create_api_key", "user:profile", "user:inference"]
  ]
end
```

#### OAuthToken Struct
```elixir
defmodule TheMaestro.Auth.OAuthToken do
  @moduledoc """
  OAuth token structure matching llxprt format
  """
  
  @type t :: %__MODULE__{
    access_token: String.t(),
    refresh_token: String.t() | nil,
    expiry: integer(), # Unix timestamp
    scope: String.t() | nil,
    token_type: String.t()
  }
  
  defstruct [
    :access_token,
    :refresh_token,
    :expiry,
    :scope,
    token_type: "Bearer"
  ]
end
```

#### DeviceCodeResponse Struct
```elixir
defmodule TheMaestro.Auth.DeviceCodeResponse do
  @moduledoc """
  Simulated device code response for OAuth flow
  """
  
  @type t :: %__MODULE__{
    device_code: String.t(),
    user_code: String.t(),
    verification_uri: String.t(),
    verification_uri_complete: String.t(),
    expires_in: integer(),
    interval: integer()
  }
  
  defstruct [
    :device_code,
    :user_code,
    :verification_uri,
    :verification_uri_complete,
    :expires_in,
    :interval
  ]
end
```

#### PKCEParams Struct
```elixir
defmodule TheMaestro.Auth.PKCEParams do
  @moduledoc """
  PKCE parameters for OAuth 2.0 security
  """
  
  @type t :: %__MODULE__{
    code_verifier: String.t(),
    code_challenge: String.t(),
    code_challenge_method: String.t()
  }
  
  defstruct [
    :code_verifier,
    :code_challenge,
    code_challenge_method: "S256"
  ]
end
```

### File Structure and Locations
[Source: docs/architecture/source-tree.md]
**New Files to Create:**
- `lib/the_maestro/auth.ex` - Main Auth module with embedded simple structs and OAuth functions
- `test/the_maestro/auth_test.exs` - Auth module tests

**Files to Modify:**
- `config/runtime.exs` - Add OAuth configuration loading

**Note**: OAuth structs (AnthropicOAuthConfig, OAuthToken, DeviceCodeResponse, PKCEParams) are simple data structures and will be embedded in the main `auth.ex` module following Phoenix conventions for simple structs.

### Integration with Existing System
**Tesla HTTP Client Integration:**
[Source: Story 1.2 implementation]
- Use existing Tesla + Finch infrastructure for OAuth HTTP requests
- Leverage existing error handling and retry patterns
- Follow existing configuration loading patterns from runtime.exs
- Integrate with existing provider pattern established in Stories 1.1 and 1.2

**Configuration Pattern:**
```elixir
# config/runtime.exs OAuth configuration
config :the_maestro, :anthropic_oauth,
  client_id: System.get_env("ANTHROPIC_CLIENT_ID") || "9d1c250a-e61b-44d9-88ed-5944d1962f5e",
  authorization_endpoint: "https://claude.ai/oauth/authorize",
  token_endpoint: "https://console.anthropic.com/v1/oauth/token",
  redirect_uri: "https://console.anthropic.com/oauth/code/callback",
  scopes: ["org:create_api_key", "user:profile", "user:inference"]
```

### OAuth User Flow Process
**Step-by-Step Flow:**
1. System generates PKCE parameters (code_verifier, code_challenge)
2. System constructs authorization URL with exact llxprt parameters
3. System displays URL to user for manual authorization
4. User visits URL, authorizes application, receives code
5. User inputs authorization code (format: `code#state` or just `code`)
6. System parses code and state from user input
7. System exchanges code for tokens using JSON request
8. System stores tokens for future API requests

**User Experience:**
- System provides clear instructions for OAuth authorization
- User manually visits authorization URL in browser
- User completes authorization and copies code
- User pastes code back into system
- System confirms successful authentication

### Security Considerations
[Source: docs/architecture/security-architecture.md references]
- PKCE (S256) implementation prevents authorization code interception
- State parameter prevents CSRF attacks (using code_verifier as state)
- Secure token storage following existing credential management patterns
- No hardcoded secrets - client_id can be overridden via environment variable
- Proper error handling without exposing sensitive OAuth details
- Token expiry validation and refresh token support

### Error Handling Patterns
**OAuth-Specific Errors:**
- Invalid authorization code → Clear error message for user
- Expired authorization code → Prompt for new authorization
- Network failures during token exchange → Retry with exponential backoff
- Malformed token response → Detailed error logging for debugging
- Missing PKCE parameters → Internal error (should not happen)

### Testing Context
[Source: docs/standards/testing-strategies.md]
**Required Test Categories:**
1. **Unit Tests**: OAuth URL generation, PKCE generation, token exchange logic
2. **Integration Tests**: Full OAuth flow with mock Anthropic responses
3. **Error Handling Tests**: Invalid codes, network failures, malformed responses
4. **Security Tests**: PKCE parameter validation, state parameter handling

**Test File Location**: `test/the_maestro/auth_test.exs`
**Framework**: ExUnit with standard Phoenix testing patterns
**Integration Testing**: Use mock OAuth endpoints for predictable testing

### Technical Dependencies
All dependencies already installed via Stories 1.1 and 1.2:
- Tesla ~> 1.11 (HTTP client for OAuth requests)
- Finch ~> 0.19 (HTTP connection pooling)
- Phoenix 1.8.0 (configuration and application structure)
- :crypto (built-in, for PKCE parameter generation)

## Dev Agent Record

### Agent Model Used
_TBD - To be filled by development agent_

### Debug Log References
_TBD - To be filled by development agent_

### Completion Notes List
_TBD - To be filled by development agent_

### File List
_TBD - To be filled by development agent_

## QA Results
_TBD - To be filled by QA agent_

## Testing

### Testing Standards
[Source: docs/standards/testing-strategies.md]

**Testing Requirements:**
- **Test Location**: `test/the_maestro/auth_test.exs`
- **Framework**: ExUnit (standard Elixir testing)
- **Testing Standards**: Follow TDD principles with Red-Green-Refactor
- **Test Structure**: Use describe blocks for organizing tests by functionality

**Required Test Cases:**
- Unit tests for OAuth URL generation with exact parameter order
- Unit tests for PKCE parameter generation and validation
- Unit tests for authorization code parsing (code#state format)
- Unit tests for token exchange request formatting (JSON, not form-encoded)
- Integration tests with mock Anthropic OAuth endpoints
- Error handling tests for all failure scenarios

**Quality Gates:**
- All tests must pass with `mix test`
- Code must pass `mix format` and `mix credo`
- Integration tests must validate exact llxprt compliance
- Security tests must verify PKCE and state parameter handling

### Archon Research Requirements
[Source: docs/standards/project-specific-rules.md]

**MANDATORY Research Before Implementation:**
```bash
# Research OAuth 2.0 best practices
archon:perform_rag_query(
  query="OAuth 2.0 authorization code flow PKCE best practices",
  match_count=3
)

# Research Elixir OAuth implementation patterns
archon:search_code_examples(
  query="Elixir OAuth 2.0 implementation examples",
  match_count=3
)

# Research Tesla HTTP client OAuth usage
archon:search_code_examples(
  query="Tesla HTTP client OAuth authentication examples",
  match_count=3
)

# Research PKCE implementation in Elixir
archon:search_code_examples(
  query="PKCE code challenge S256 Elixir implementation",
  match_count=2
)
```

**Research Integration Requirements:**
- Cross-reference OAuth security best practices
- Validate Tesla HTTP client patterns for OAuth flows
- Ensure PKCE implementation follows RFC 7636 standard
- Verify token exchange security patterns

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-28 | 1.0 | Initial story creation with comprehensive llxprt OAuth analysis and exact implementation requirements | Scrum Master (Bob) |
| 2025-01-28 | 1.1 | Story validated and approved - ready for development | BMad:po |