# Story 1.6: OpenAI OAuth - URL Generation & Token Exchange

## Status
**Approved**

## Story
**As the system,**
**I want** to generate an OpenAI OAuth 2.0 URL and handle the token exchange,
**so that** I can authenticate with OpenAI using OAuth instead of API keys and provide users with flexible authentication options.

## Acceptance Criteria

1. The `LLMOrchestrator.Auth` module can generate a valid OpenAI OAuth 2.0 authorization URL.

2. The module can accept an authorization code and exchange it for an `access_token` and `refresh_token` from OpenAI's token endpoint.

## Tasks / Subtasks

- [ ] **Task 1: Research OpenAI OAuth 2.0 authentication patterns** (AC: 1, 2)
  - [ ] **MANDATORY: Research OpenAI OAuth authentication patterns before implementation**
    - [ ] Query Archon for OpenAI OAuth authentication best practices: `archon:perform_rag_query(query="OpenAI OAuth 2.0 authentication best practices", match_count=3)`
    - [ ] Query Archon for OAuth PKCE implementation examples: `archon:search_code_examples(query="OAuth PKCE implementation examples Elixir", match_count=3)`
    - [ ] Query Archon for OpenAI OAuth integration examples: `archon:search_code_examples(query="OpenAI OAuth integration examples", match_count=3)`
  - [ ] Extract exact OAuth configuration requirements from OpenAI API documentation
  - [ ] Document differences between OpenAI and Anthropic OAuth implementations
  - [ ] Validate OpenAI OAuth flow requirements and PKCE usage patterns

- [ ] **Task 2: Extend Auth module for OpenAI OAuth URL generation** (AC: 1)
  - [ ] **MANDATORY: Add comprehensive @spec declarations for ALL OpenAI OAuth functions:**
    - `@spec generate_openai_oauth_url() :: {:ok, {String.t(), PKCEParams.t()}} | {:error, term()}`
    - `@spec get_openai_oauth_config() :: {:ok, OpenAIOAuthConfig.t()} | {:error, term()}`
    - `@spec build_openai_oauth_params(OpenAIOAuthConfig.t(), PKCEParams.t()) :: map()`
  - [ ] **MANDATORY: Define required structs for OpenAI OAuth configuration:**
    - `%OpenAIOAuthConfig{client_id: binary(), authorization_endpoint: binary(), token_endpoint: binary(), redirect_uri: binary(), scopes: [binary()]}` struct with typed fields
    - Configuration validation for missing OAuth parameters with proper error types
  - [ ] Add OpenAI OAuth URL generation function following established PKCE patterns
  - [ ] Implement OpenAI-specific OAuth configuration with proper endpoint URLs
  - [ ] Add OpenAI OAuth configuration loading from environment variables
  - [ ] Ensure OAuth URL generation follows OpenAI OAuth 2.0 specification

- [ ] **Task 3: Implement OpenAI OAuth token exchange** (AC: 2)
  - [ ] **MANDATORY: Add comprehensive @spec declarations for token exchange functions:**
    - `@spec exchange_openai_code_for_tokens(String.t(), PKCEParams.t()) :: {:ok, OAuthToken.t()} | {:error, term()}`
    - `@spec validate_openai_token_response(map()) :: {:ok, OAuthToken.t()} | {:error, term()}`
    - `@spec build_openai_token_request(String.t(), PKCEParams.t(), OpenAIOAuthConfig.t()) :: map()`
  - [ ] **MANDATORY: Define required structs for OpenAI OAuth responses:**
    - Extend existing `%OAuthToken{}` struct to support OpenAI token format
    - `%OpenAITokenResponse{access_token: binary(), refresh_token: binary() | nil, expires_in: integer(), scope: binary() | nil, token_type: binary()}` struct for response mapping
  - [ ] Implement OpenAI OAuth token exchange using PKCE verification
  - [ ] Add OpenAI OAuth token endpoint HTTP client configuration
  - [ ] Implement proper error handling for OpenAI OAuth failures
  - [ ] Add token response validation and mapping to standard OAuthToken format

- [ ] **Task 4: Add OpenAI OAuth configuration** (AC: 1, 2)
  - [ ] **MANDATORY: Add comprehensive @spec declarations for configuration functions:**
    - `@spec load_openai_oauth_config() :: {:ok, map()} | {:error, term()}`
    - `@spec validate_openai_oauth_environment() :: {:ok, map()} | {:error, term()}`
  - [ ] Add OpenAI OAuth configuration to runtime.exs with environment variables
  - [ ] Add OpenAI OAuth client ID, endpoints, and scope configuration
  - [ ] Update OAuth configuration patterns to support both Anthropic and OpenAI
  - [ ] Add OpenAI OAuth redirect URI and authorization scope configuration

- [ ] **Task 5: Write comprehensive tests** (AC: 1, 2)
  - [ ] **MANDATORY: Add comprehensive @spec declarations for ALL test helper functions:**
    - `@spec build_mock_openai_oauth_config() :: map()`
    - `@spec mock_openai_oauth_response() :: {:ok, map()} | {:error, term()}`
    - `@spec assert_openai_oauth_url_format(String.t()) :: boolean()`
    - `@spec mock_openai_token_exchange_response() :: map()`
  - [ ] **MANDATORY: Define required structs for test data:**
    - `%MockOpenAIOAuthConfig{client_id: binary(), endpoints: map(), scopes: [binary()], expected_error: atom() | nil}` struct for OAuth test scenarios
    - `%TestOpenAITokenResponse{access_token: binary(), refresh_token: binary() | nil, expires_in: integer(), status: integer()}` struct for token exchange testing
  - [ ] Test OpenAI OAuth URL generation with proper PKCE parameters
  - [ ] Test OpenAI OAuth token exchange with authorization code
  - [ ] Test error handling for invalid OAuth codes and missing configuration
  - [ ] Test OpenAI vs Anthropic OAuth flow differences and compatibility
  - [ ] **MANDATORY: Include manual OAuth testing protocol per testing-strategies.md**
    - Manual testing with real OpenAI OAuth flow for end-to-end validation
    - Product Owner or tester performs actual OAuth authorization in browser
    - Validation of complete OAuth flow with real OpenAI authorization server

- [x] **Task 6: Update configuration and documentation** (AC: All)
  - [x] **MANDATORY: Add comprehensive @spec declarations for documentation functions:**
    - `@spec get_openai_oauth_flow_example() :: String.t()`
    - `@spec validate_openai_oauth_documentation() :: {:ok, map()} | {:error, term()}`
  - [x] Update runtime.exs configuration for OpenAI OAuth client ID and endpoints
  - [x] Add OpenAI OAuth configuration examples and environment variable documentation
  - [x] Document OpenAI OAuth workflow and authorization flow requirements
  - [x] Update Auth module documentation with OpenAI OAuth authentication examples
  - [x] Add code examples for OpenAI OAuth URL generation and token exchange
  - [x] Update type specifications and module documentation for OpenAI support

## Dev Notes

### Previous Story Context
[Source: Story 1.5 completion notes]
Story 1.5 successfully implemented OpenAI API key authentication with comprehensive Bearer token support. The infrastructure now available includes:

**Client Infrastructure Available:**
- `TheMaestro.Providers.Client` module with Tesla-based HTTP client using Finch adapter
- `build_client/1` function supporting `:openai` provider with Bearer token authentication
- OpenAI-specific middleware patterns for headers, JSON, logging, retry, and authentication
- Finch connection pools configured for OpenAI (`https://api.openai.com`)
- Comprehensive error handling patterns for authentication failures
- OpenAIConfig module for configuration management

**Key Integration Points:**
- Tesla dependency (~> 1.11) with Finch adapter configured for OpenAI
- OpenAI configuration system established in runtime.exs
- Error handling patterns established for network failures and authentication issues
- Header injection patterns for OpenAI Bearer token authentication established

### OAuth Infrastructure Available
[Source: Story 1.4 and existing Auth module analysis]
Story 1.4 successfully implemented Anthropic OAuth authentication with comprehensive infrastructure:

**OAuth Infrastructure Available:**
- `TheMaestro.Auth` module with complete OAuth 2.0 implementation
- PKCE (Proof Key for Code Exchange) support with S256 method
- OAuth URL generation with secure parameter handling
- Authorization code exchange for access and refresh tokens
- `SavedAuthentication` schema for encrypted credential storage
- HTTPoison-based OAuth token requests (separate from Tesla API client)

**Key OAuth Components:**
- `AnthropicOAuthConfig` struct pattern for provider-specific configuration
- `OAuthToken` struct for standardized token representation
- `PKCEParams` struct for secure PKCE parameter management
- Complete OAuth workflow with URL generation and token exchange
- JSON request format for OAuth token endpoint (not form-encoded)

### Architecture Context

**System Architecture Integration:**
[Source: docs/architecture/system-architecture-logical-view.md]
- Tesla/Finch HTTP Client: Single point of contact for all outbound API requests
- Auth Handlers: Provider-specific modules implementing OAuth 2.0 authentication flows
- Oban Background Jobs: Critical role in handling periodic refreshing of OAuth tokens
- Named Finch pools for each provider for efficient HTTP/2 connection management

**OAuth Security Requirements:**
[Source: docs/architecture/security-architecture.md]
- Credential Storage: All OAuth tokens encrypted at rest using ClakEcto with AES-256
- Token Hijacking Prevention: Secure storage with HTTP-only, encrypted tokens
- API Key vs OAuth Security: OAuth provides additional security with refresh capabilities
- Never log sensitive OAuth data including access tokens and refresh tokens

### OpenAI OAuth Requirements

**OpenAI OAuth 2.0 Configuration:**
[Source: PRD Epic 1 Story 1.6 requirements]
**OpenAI OAuth 2.0 Specifications** (Based on actual Codex CLI implementation):

**OAuth Configuration:**
- **Client ID**: `app_EMoamEEZ73f0CkXaXp7hrann` (public client)
- **Authorization URL**: `https://auth.openai.com/oauth/authorize`
- **Token Endpoint**: `https://auth.openai.com/oauth/token`
- **OAuth Scopes**: `"openid profile email offline_access"`
- **PKCE Method**: `S256` (SHA-256) - âœ… Required for security
- **OAuth Flow**: Authorization Code Flow with PKCE (no client secret needed)

**Required OAuth Parameters for Authorization URL:**
```elixir
%{
  response_type: "code",
  client_id: "app_EMoamEEZ73f0CkXaXp7hrann",
  redirect_uri: "http://localhost:#{port}/auth/callback",
  scope: "openid profile email offline_access", 
  code_challenge: pkce_code_challenge,
  code_challenge_method: "S256",
  state: secure_random_state
}
```

**Token Exchange Request Format:**
```http
POST https://auth.openai.com/oauth/token
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&
code={authorization_code}&
redirect_uri={callback_uri}&
client_id=app_EMoamEEZ73f0CkXaXp7hrann&
code_verifier={pkce_verifier}
```

**Configuration Requirements:**
- No client secret needed (public client with PKCE)
- Uses standard OAuth 2.0 authorization code flow
- PKCE S256 method required for security
- Returns id_token, access_token, and refresh_token

### Auth Module Extension Context

**Current Auth Module Structure:**
[Source: Analysis of lib/the_maestro/auth.ex]
The existing Auth module supports:
- Anthropic OAuth 2.0 implementation with complete workflow
- PKCE parameter generation and validation (S256 method)
- OAuth URL generation with proper parameter encoding
- Authorization code exchange with JSON request format
- Structured configuration with embedded structs
- Comprehensive error handling and logging

**Integration Requirements for OpenAI:**
- Extend existing Auth module with OpenAI-specific OAuth functions
- Create OpenAI OAuth configuration struct following Anthropic pattern
- Add OpenAI OAuth URL generation function using existing PKCE infrastructure
- Implement OpenAI token exchange using established HTTPoison patterns
- Maintain compatibility with existing OAuth token management systems

### SavedAuthentication Schema Integration

**Current Schema Support:**
[Source: Analysis of lib/the_maestro/saved_authentication.ex]
- Provider field supports :anthropic, :openai, :gemini enum values
- Auth_type field supports :api_key and :oauth enum values
- Encrypted credentials storage with :map field type
- Expiry tracking with :expires_at field for OAuth token management
- Unique constraint on provider + auth_type combinations

**OpenAI OAuth Integration:**
- No schema changes required - existing schema supports OpenAI OAuth
- OAuth credentials will be stored with provider: :openai, auth_type: :oauth
- Encrypted storage of OpenAI access_token and refresh_token
- Expiry tracking for OpenAI OAuth token lifecycle management

### File Locations and Naming Conventions
[Source: docs/architecture/source-tree.md]

**Files to Modify:**
- `lib/the_maestro/auth.ex` - Add OpenAI OAuth authentication support
- `config/runtime.exs` - Add OpenAI OAuth configuration
- `test/the_maestro/auth_test.exs` - Add comprehensive OAuth tests (create if doesn't exist)
- `docs/stories/1.6.story.md` - This story documentation

**Configuration Structure:**
- Environment variables: `OPENAI_OAUTH_CLIENT_ID`, `OPENAI_OAUTH_CLIENT_SECRET` (if required)
- Runtime configuration for OAuth endpoint and scope loading
- OAuth configuration following established Anthropic patterns

### Testing Requirements
[Source: docs/standards/testing-strategies.md]

**Testing Standards:**
- Test file location: `test/the_maestro/auth_test.exs` (extend or create)
- Framework: ExUnit with standard Phoenix testing patterns
- Manual OAuth testing: **MANDATORY** per OAuth Flow Testing Protocol
- Mock testing: Create mock responses for predictable unit testing

**Required Test Categories:**
1. **Unit Tests**: OAuth URL generation, PKCE parameter validation, token exchange logic
2. **Integration Tests**: Complete OAuth flow with mock OAuth provider responses
3. **Configuration Tests**: Missing OAuth configuration handling, environment variable loading
4. **Error Handling Tests**: Invalid authorization codes, network failures, malformed responses
5. **Comparison Tests**: OpenAI vs Anthropic OAuth flow format validation
6. **Manual OAuth Tests**: Real OpenAI OAuth provider integration (per testing-strategies.md)

**Manual OAuth Testing Protocol (MANDATORY):**
- Dev/QA team generates OpenAI OAuth authorization URL
- Product Owner manually completes OAuth authorization in browser
- Tester extracts authorization code from callback URL
- Dev/QA uses provided code to test complete token exchange flow
- End-to-end verification that OAuth tokens authenticate API requests successfully

**Quality Gates:**
- All tests must pass with `mix test`
- Code must pass `mix format` and `mix credo --strict`
- Manual OAuth testing must validate real OpenAI provider integration
- Integration tests must validate OAuth token lifecycle management

### Technical Dependencies
[Source: Previous story implementations and architecture]

**Existing Dependencies (Already Available):**
- HTTPoison ~> 2.0 - HTTP client for OAuth token requests (separate from Tesla)
- Jason ~> 1.4 - JSON encoding/decoding for OAuth requests and responses
- Configuration system - Runtime environment variable loading
- PKCE infrastructure - S256 method support from Anthropic implementation
- Error handling patterns - Consistent error types and messaging

**Integration Patterns:**
- Use existing PKCE infrastructure from Anthropic OAuth implementation
- Leverage established OAuth URL generation and token exchange patterns
- Follow existing configuration and error handling patterns
- Maintain compatibility with SavedAuthentication schema for credential storage

### Security Considerations
[Source: docs/architecture/security-architecture.md and testing-strategies.md]

**OAuth Security Implementation:**
- Use PKCE (Proof Key for Code Exchange) for enhanced OAuth security
- Generate cryptographically secure PKCE parameters using S256 method
- Store OAuth tokens encrypted at rest in SavedAuthentication table
- Never log OAuth access tokens or refresh tokens in plaintext
- Use HTTPS for all OAuth authorization and token exchange requests

**Error Handling Security:**
- Avoid exposing OAuth client secrets in error messages
- Log OAuth failures without sensitive authorization information
- Implement proper error types for missing/invalid OAuth configuration
- Follow established error handling patterns from Anthropic OAuth implementation

### Archon Research Requirements
[Source: docs/standards/project-specific-rules.md and coding standards]

**MANDATORY Research Before Implementation:**
```bash
# Research OpenAI OAuth 2.0 authentication patterns
archon:perform_rag_query(
  query="OpenAI OAuth 2.0 authentication best practices",
  match_count=3
)

# Research OAuth PKCE implementation patterns
archon:search_code_examples(
  query="OAuth PKCE implementation examples Elixir", 
  match_count=3
)

# Research OpenAI OAuth integration examples
archon:search_code_examples(
  query="OpenAI OAuth integration examples",
  match_count=3
)

# Research OAuth security best practices
archon:perform_rag_query(
  query="OAuth 2.0 security best practices PKCE",
  match_count=2
)
```

**Research Integration Requirements:**
- Cross-reference OpenAI OAuth 2.0 security best practices and PKCE requirements
- Validate OAuth endpoint configuration and authorization flow patterns
- Ensure OAuth implementation follows OpenAI API documentation specifications
- Verify OAuth token lifecycle management and refresh token handling

### Testing
[Source: docs/standards/testing-strategies.md]

**Testing Requirements:**
- **Test Locations**: 
  - `test/the_maestro/auth_test.exs` (extend existing or create new tests)
- **Framework**: ExUnit (standard Elixir testing)
- **Testing Standards**: Follow TDD principles with Red-Green-Refactor cycle
- **Test Structure**: Use describe blocks for organizing tests by functionality

**Required Test Cases:**
- OpenAI OAuth URL generation with proper PKCE parameters and state handling
- OAuth authorization code exchange for access and refresh tokens
- Configuration loading from environment variables (OPENAI_OAUTH_CLIENT_ID, etc.)
- Error handling for missing OAuth configuration and invalid authorization codes
- Integration tests validating OpenAI vs Anthropic OAuth differences
- **MANDATORY**: Manual OAuth testing with real OpenAI OAuth provider per testing-strategies.md

**Manual OAuth Testing Requirements:**
1. **OAuth URL Generation**: Test `generate_openai_oauth_url()` creates valid OpenAI authorization URL
2. **Manual Authorization**: Product Owner completes OAuth flow through OpenAI's authorization interface
3. **Code Exchange Testing**: Test `exchange_openai_code_for_tokens()` with real authorization code
4. **Token Validation**: Verify OAuth tokens can authenticate OpenAI API requests
5. **Error Testing**: Test invalid codes and configuration scenarios
6. **Flow Comparison**: Validate OpenAI OAuth differs correctly from Anthropic implementation

**Quality Gates:**
- All automated tests must pass with `mix test`
- Code must pass `mix format` and `mix credo --strict`
- **MANDATORY**: Manual OAuth testing with real OpenAI provider must succeed
- Integration tests must validate complete OAuth token lifecycle
- OAuth security requirements must be validated through testing

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-29 | 1.0 | Initial story creation with comprehensive OpenAI OAuth 2.0 requirements, building on existing OAuth infrastructure from Story 1.4 and Tesla + Finch from Stories 1.1-1.5 | Scrum Master (Bob) |
| 2025-08-29 | 1.1 | Story validation completed with template compliance fixes - CONDITIONAL APPROVAL pending OpenAI OAuth endpoint specification | BMad:po |
| 2025-08-29 | 1.2 | OpenAI OAuth specifications added from Codex CLI implementation analysis - STORY APPROVED | BMad:po |

## Dev Agent Record

### Agent Model Used
*To be populated by the development agent during implementation*

### Debug Log References
*To be populated by the development agent with references to debug logs or traces generated during development*

### Completion Notes List
*To be populated by the development agent with notes about task completion and any issues encountered*

### File List
*To be populated by the development agent with all files created, modified, or affected during story implementation*

## QA Results

*To be populated by the QA Agent with results from QA review of the completed story implementation*