# Story 0.5: Gemini Provider Complete Implementation

## Status
**Approved - Epic 0 Gemini Modular Implementation**

## Implementation Source (10000% Working Code)
- Canonical reference: `/Users/jasonk/Development/the_maestro/source/gemini-cli`
- Gemini auth, streaming, and model patterns MUST be adapted from the above source to ensure 10000% working behavior.

## Plan Alignment
- This story follows `docs/prd/EMERGENCY-COURSE-CORRECT-PRD-gpt.md` (GPT variant). Match streaming adapter usage, interface parity, and E2E acceptance from the PRD.

## Story
**As the system,**
**I want** a complete Gemini provider implementation using the universal provider interface with both OAuth and API key authentication modes and full streaming integration,
**so that** I can provide seamless Gemini access through the generic interface while supporting both Google OAuth authentication and API key methods with proper model listing and streaming capabilities.

## Acceptance Criteria

### AC-TYPES: Types/Specs/Structs Required
1. All public functions in the Gemini provider include explicit `@spec` annotations.
2. Complex objects (candidates, content parts, function calls, usage metadata) are defined as typed structs with `@typedoc`, `@type t`, and `@enforce_keys` where appropriate.
3. Public APIs accept/return structs instead of ad-hoc maps across module boundaries.
4. Add type aliases for Gemini concepts and reuse consistently.
5. Credo/Dialyzer pass with zero type/spec warnings.

### AC-1: Modular Gemini Provider Structure
1. Complete Gemini provider implementation following the universal provider architecture with separate modules for OAuth, API Key, Streaming, and Models.
2. All Gemini operations accessible exclusively through `TheMaestro.Provider` interface with no direct provider module calls.
3. Provider modules implement all required behaviors (OAuth, API Key, Streaming, Model) with full compliance validation.
4. Named session support enabling multiple concurrent Gemini authentication sessions.

### AC-2: Dual-Mode Authentication Implementation
1. OAuth authentication using Google OAuth 2.0 with PKCE support, following patterns from `gemini-cli` reference implementation.
2. API key authentication mode supporting Google AI Studio API keys for simpler integration.
3. Automatic authentication mode detection and appropriate endpoint routing based on session configuration.
4. Token refresh workflow using Google OAuth refresh tokens with automatic background refresh worker support.

### AC-3: Universal Streaming Integration
1. Gemini streaming responses flow through the unified `TheMaestro.Streaming.parse_stream/3` interface.
2. Integration with existing `TheMaestro.Streaming.GeminiHandler` for Gemini streaming response processing.
3. Streaming responses processed through the Req streaming adapter with proper SSE parsing.
4. Streaming interruption and error recovery work consistently with the universal streaming architecture.

### AC-4: Comprehensive E2E Validation
1. Complete end-to-end test covering OAuth authorization → token exchange → streaming response and API key → streaming response.
2. Real Gemini provider integration testing with both OAuth and API key authentication modes.
3. Both authentication modes tested with standardized prompt and response validation using latest Gemini models.
4. Error handling, token refresh, and edge case validation across both authentication modes.

### AC-4b: Dual‑Prompt E2E Requirement (0.3–0.5 Alignment)
All Gemini E2E tests must:
1) Ask "What is the capital of France?" and verify output contains "Paris" (case‑insensitive)
2) Ask "How would you write a FastAPI application that handles Stripe-based subscriptions?" and WAIT up to 5 minutes (or until stream completes)
Use `scripts/e2e_dual_prompt_stream_test.exs` with provider `gemini` and the relevant session.

### AC-5: Endpoints & Headers by Auth Type (OAuth, Personal API Key, Enterprise API Key)
1. Base API: `https://generativelanguage.googleapis.com`.
2. OAuth (personal account):
   - Endpoint (streaming): `POST /v1beta/models/{model}:streamGenerateContent`.
   - Headers: `Authorization: Bearer <access_token>`, `Content-Type: application/json`.
3. Personal API key (AI Studio):
   - Endpoint (streaming): same as OAuth.
   - Auth: `X-Goog-Api-Key: <api_key>` (or `?key=<api_key>` query parameter).
   - Headers: `Content-Type: application/json`.
4. Enterprise API key:
   - Endpoint (streaming): same as OAuth (unless region-specific enterprise endpoint is configured).
   - Auth: `X-Goog-Api-Key: <api_key>` and optional `X-Goog-User-Project: <gcp_project_id>`.
   - Headers: `Content-Type: application/json`.
5. Tests validate header presence (including optional `X-Goog-User-Project`) and correct endpoint usage per mode.

### AC-6: Model Listing & Streaming Across All Auth Types
1. `TheMaestro.Provider.list_models(:gemini, auth_type, session)` works with OAuth, personal API key, and enterprise API key.
2. Streaming uses Req streaming + SSE adapter into `TheMaestro.Streaming.parse_stream/3` with `TheMaestro.Streaming.GeminiHandler`.

## Tasks / Subtasks

### Task 1: Research Gemini OAuth and API Patterns (AC-1, AC-2)
**Duration:** 1 day  
**Priority:** CRITICAL - Foundation research for implementation patterns

- [ ] **Task 1.1: Research gemini-cli Implementation Patterns** (AC-1, AC-2)
  - [ ] **MANDATORY: Analyze existing gemini-cli OAuth implementation**
  - [ ] **Research source location:** `/Users/jasonk/Development/the_maestro/source/gemini-cli`
  - [ ] **Key files to analyze:**
    ```
    packages/core/src/code_assist/oauth2.ts        # Main OAuth implementation
    packages/core/src/mcp/google-auth-provider.ts  # Google Auth patterns  
    packages/core/src/mcp/oauth-utils.ts           # OAuth utilities
    packages/core/src/mcp/oauth-token-storage.ts   # Token management
    ```
  - [ ] **Extract OAuth patterns:** PKCE implementation, Google client setup, token exchange flows
  - [ ] **Extract API key patterns:** Google AI Studio integration, authentication headers
  - [ ] **Validation: Comprehensive analysis of gemini-cli OAuth and API key authentication patterns**

- [ ] **Task 1.2: Google OAuth 2.0 Configuration Research** (AC-2)
  - [ ] **Research Google Cloud OAuth setup requirements**
  - [ ] **OAuth client configuration:** Desktop application, redirect URIs, scopes
  - [ ] **Required scopes for Gemini API access:**
    ```
    https://www.googleapis.com/auth/cloud-platform
    https://www.googleapis.com/auth/userinfo.email  
    https://www.googleapis.com/auth/userinfo.profile
    https://www.googleapis.com/auth/generative-language.retriever
    ```
  - [ ] **PKCE implementation requirements and security considerations**
  - [ ] **Validation: Complete OAuth configuration requirements documented**

- [ ] **Task 1.3: Gemini API Endpoints and Model Research** (AC-1)
  - [ ] **Research current Gemini model families and capabilities**
  - [ ] **API endpoint patterns:** OAuth vs API key endpoint differences
  - [ ] **Model listing endpoints:** `https://generativelanguage.googleapis.com/v1/models`
  - [ ] **Streaming endpoints:** `https://generativelanguage.googleapis.com/v1/models/{model}:streamGenerateContent`
  - [ ] **Model capabilities:** Gemini 2.5 Pro, 2.5 Flash, 2.0 Flash, context windows, pricing
  - [ ] **Validation: Complete Gemini API endpoint and model documentation**

### Task 2: Gemini Provider Module Structure (AC-1)
**Duration:** 2 days  
**Priority:** CRITICAL - Foundation for modular Gemini implementation

- [ ] **Task 2.1: Provider Directory Structure Creation** (AC-1)
  - [ ] **MANDATORY: Create complete Gemini provider module structure**
    ```
    lib/the_maestro/providers/gemini/
    ├── oauth.ex                   # OAuth implementation with Google OAuth 2.0
    ├── api_key.ex                 # API key authentication implementation  
    ├── streaming.ex               # Streaming implementation using existing handler
    ├── models.ex                  # Gemini model listing and information
    └── config.ex                  # Provider configuration and constants
    ```
  - [ ] **Each module must implement required provider behaviors from Story 0.1**
  - [ ] **Validation: Directory structure matches universal provider pattern**

- [x] **Task 2.2: OAuth Module Implementation** (AC-1, AC-2)
  - [ ] **MANDATORY: Implement `TheMaestro.Providers.Gemini.OAuth`**
  - [ ] **OAuth behavior implementation based on gemini-cli patterns:**
    ```elixir
    @behaviour TheMaestro.Provider.OAuth
    
    @impl true
    def generate_auth_url(session_id, opts \\ [])
    
    @impl true  
    def exchange_code_for_tokens(session_id, authorization_code, opts \\ [])
    
    @impl true
    def refresh_tokens(session_id, opts \\ [])
    
    @impl true
    def revoke_tokens(session_id, opts \\ [])
    ```
  - [ ] **Google OAuth 2.0 with PKCE implementation following gemini-cli patterns**
  - [ ] **Integration with Google OAuth endpoints: `https://oauth2.googleapis.com/`**
  - [ ] **Validation: OAuth module compiles and implements all required callbacks**

- [x] **Task 2.3: API Key Module Implementation** (AC-1, AC-2)
  - [ ] **MANDATORY: Implement `TheMaestro.Providers.Gemini.ApiKey`**
  - [ ] **API Key behavior implementation:**
    ```elixir
    @behaviour TheMaestro.Provider.ApiKey
    
    @impl true
    def create_session(api_key, opts \\ [])
    
    @impl true
    def validate_session(session_id, opts \\ [])
    
    @impl true
    def delete_session(session_id, opts \\ [])
    ```
  - [ ] **Google AI Studio API key validation with Gemini API**
  - [ ] **Session management for API key authentication**
  - [ ] **Validation: API key module compiles and implements all required callbacks**

- [x] **Task 2.4: Models Module Implementation** (AC-1)
  - [ ] **MANDATORY: Implement `TheMaestro.Providers.Gemini.Models`**
  - [ ] **Models behavior implementation:**
    ```elixir
    @behaviour TheMaestro.Provider.Models
    
    @impl true
    def list_models(session_id, opts \\ [])
    
    @impl true
    def get_model_info(session_id, model_id, opts \\ [])
    ```
  - [ ] **Gemini model listing (2.5 Pro, 2.5 Flash, 2.0 Flash, etc.)**
  - [ ] **Model capability information: context windows, pricing, capabilities**
  - [ ] **Support for both OAuth and API key authentication modes**
  - [ ] **Validation: Models module compiles and returns proper model information**

### Task 3: Google OAuth Implementation (AC-2)
**Duration:** 2.5 days
**Priority:** HIGH - Complex OAuth flow based on gemini-cli patterns

- [x] **Task 3.1: Google OAuth Client Setup** (AC-2)
  - [ ] **MANDATORY: Implement Google OAuth 2.0 client configuration**
  - [ ] **OAuth client setup based on gemini-cli patterns:**
    ```elixir
    # Google OAuth 2.0 configuration
    @oauth_client_id "YOUR_GOOGLE_CLIENT_ID"
    @oauth_client_secret "YOUR_GOOGLE_CLIENT_SECRET"  
    @oauth_scopes [
      "https://www.googleapis.com/auth/cloud-platform",
      "https://www.googleapis.com/auth/userinfo.email",
      "https://www.googleapis.com/auth/userinfo.profile",
      "https://www.googleapis.com/auth/generative-language.retriever"
    ]
    ```
  - [ ] **PKCE code verifier and challenge generation**
  - [ ] **State parameter for CSRF protection**
  - [ ] **Validation: OAuth client configuration works with Google endpoints**

- [ ] **Task 3.2: OAuth Authorization Flow** (AC-2)
  - [x] **MANDATORY: Implement OAuth authorization URL generation**
  - [ ] **Google OAuth 2.0 authorization endpoint integration:**
    ```
    https://accounts.google.com/oauth2/auth?
    client_id={client_id}&
    redirect_uri={redirect_uri}&
    response_type=code&
    scope={scopes}&
    state={state}&
    code_challenge={code_challenge}&
    code_challenge_method=S256&
    access_type=offline&
    prompt=consent
    ```
  - [ ] **PKCE code challenge and verifier management**
  - [ ] **Callback handling for authorization code receipt**
  - [ ] **Validation: Authorization URLs are valid and PKCE secure**

- [x] **Task 3.3: Token Exchange Implementation** (AC-2)
  - [ ] **MANDATORY: Implement authorization code to token exchange**
  - [ ] **Google OAuth 2.0 token endpoint integration with Req client:**
    ```elixir
    # Form-encoded token exchange (Google OAuth standard)
    payload = %{
      grant_type: "authorization_code",
      client_id: client_id(),
      client_secret: client_secret(),
      code: authorization_code,
      code_verifier: code_verifier,
      redirect_uri: redirect_uri()
    }
    
    Req.post(url: "https://oauth2.googleapis.com/token", 
             form: payload, 
             headers: [{"content-type", "application/x-www-form-urlencoded"}])
    ```
  - [ ] **Token response validation and secure storage**
  - [ ] **Error handling for token exchange failures**
  - [ ] **Validation: Token exchange works with Google OAuth endpoints**

- [x] **Task 3.4: Token Refresh Implementation** (AC-2)
  - [ ] **MANDATORY: Implement automatic token refresh**
  - [ ] **Refresh token flow with Google OAuth endpoints**
  - [ ] **Background refresh worker integration**
  - [ ] **Token rotation and session continuity**
  - [ ] **Validation: Token refresh works automatically and maintains session continuity**

### Task 4: Streaming Integration (AC-3)
**Duration:** 1.5 days
**Priority:** HIGH - Integrate with existing streaming infrastructure

- [x] **Task 4.1: Streaming Module Implementation** (AC-3)
  - [ ] **MANDATORY: Implement `TheMaestro.Providers.Gemini.Streaming`**
  - [ ] **Streaming behavior implementation:**
    ```elixir
    @behaviour TheMaestro.Provider.Streaming
    
    @impl true
    def stream_chat(session_id, messages, opts \\ [])
    
    @impl true
    def interrupt_stream(stream_ref, opts \\ [])
    ```
  - [ ] **Integration with existing `TheMaestro.Streaming.GeminiHandler`**
  - [ ] **Req streaming adapter implementation for consistent SSE parsing**
  - [ ] **Validation: Streaming works through universal `parse_stream/3` interface**

- [x] **Task 4.2: Universal Streaming Adapter** (AC-3)
  - [ ] **MANDATORY: Create Req streaming adapter for Gemini**
  - [ ] **Adapter feeds `TheMaestro.Streaming.parse_stream/3` with proper enumerable**
  - [ ] **Consistent SSE parsing across all providers**
  - [ ] **Authentication header injection by mode**
    - [ ] OAuth: `Authorization: Bearer <access_token>`
    - [ ] Personal API key: `X-Goog-Api-Key: <api_key>` (or `?key=<api_key>`)
    - [ ] Enterprise API key: `X-Goog-Api-Key: <api_key>` (+ optional `X-Goog-User-Project`)
  - [ ] **Validation: Streaming adapter produces consistent output format**

- [x] **Task 4.3: Gemini API Streaming Implementation** (AC-3)
  - [ ] **MANDATORY: Implement Gemini streaming API calls**
  - [ ] **Streaming endpoint integration:**
    ```elixir
    # OAuth mode
    headers = [
      {"authorization", "Bearer #{access_token}"},
      {"content-type", "application/json"}
    ]
    
    # Personal API Key mode
    headers = [
      {"x-goog-api-key", api_key},
      {"content-type", "application/json"}
    ]
    
    # Enterprise API Key mode (optional billing project)
    headers =
      [
        {"x-goog-api-key", api_key},
        {"content-type", "application/json"}
      ] ++ maybe_user_project_header(opts)
    
    payload = %{
      model: "models/#{model_name}",
      contents: messages,
      stream: true
    }
    
    Req.post(
      url: "https://generativelanguage.googleapis.com/v1/models/#{model_name}:streamGenerateContent",
      json: payload,
      headers: headers,
      into: :stream
    )
    ```
  - [ ] **Error handling and recovery within streaming**
  - [ ] **Validation: Gemini streaming works with both OAuth and API key authentication**

### Task 5: Universal Provider Interface Integration (AC-1)
**Duration:** 1.5 days
**Priority:** CRITICAL - Generic interface compliance

- [x] **Task 5.1: Provider Registration** (AC-1)
  - [ ] **MANDATORY: Register Gemini provider with dynamic resolver**
  - [ ] **Update provider registry to include `:gemini` provider**
  - [ ] **Module resolution testing for all Gemini provider modules**
  - [ ] **Validation: `TheMaestro.Provider.create_session(:gemini, :oauth, opts)` works**

- [ ] **Task 5.2: Generic Interface Compliance** (AC-1)
  - [ ] **MANDATORY: Verify all generic interface methods work**
  - [ ] **Test matrix:**
    ```elixir
    # OAuth mode
    TheMaestro.Provider.create_session(:gemini, :oauth, name: "personal_gemini")
    TheMaestro.Provider.list_models(:gemini, :oauth, session_id)
    TheMaestro.Provider.stream_chat(:gemini, session_id, messages, opts)
    TheMaestro.Provider.refresh_tokens(:gemini, session_id)
    
    # API Key mode  
    TheMaestro.Provider.create_session(:gemini, :api_key, api_key: "your_api_key")
    TheMaestro.Provider.list_models(:gemini, :api_key, session_id)
    TheMaestro.Provider.stream_chat(:gemini, session_id, messages, opts)
    ```
  - [ ] **Error handling consistency across all interface methods**
  - [ ] **Validation: All generic interface methods work for both auth modes**

- [ ] **Task 5.3: Named Sessions Support** (AC-1)
  - [ ] **MANDATORY: Test multiple concurrent Gemini sessions**
  - [ ] **Named session creation and management:**
    ```elixir
    {:ok, personal_id} = TheMaestro.Provider.create_session(:gemini, :oauth, 
                                                            name: "personal_gemini")
    {:ok, work_id} = TheMaestro.Provider.create_session(:gemini, :api_key, 
                                                        name: "work_gemini", 
                                                        api_key: "your_work_key")
    ```
  - [ ] **Session isolation and proper cleanup**
  - [ ] **Validation: Multiple named Gemini sessions work independently**

### Task 6: Comprehensive Testing (AC-4)
**Duration:** 2.5 days
**Priority:** HIGH - Ensure production readiness

- [ ] **Task 6.1: Unit Tests** (AC-4)
  - [ ] **MANDATORY: Complete unit test coverage for all provider modules**
  - [ ] **Test files:**
    ```
    test/the_maestro/providers/gemini/
    ├── oauth_test.exs
    ├── api_key_test.exs
    ├── streaming_test.exs
    ├── models_test.exs
    └── config_test.exs
    ```
  - [ ] **Mock Google OAuth and Gemini API responses for testing**
  - [ ] **Error condition testing and edge cases**
  - [ ] **Validation: >90% test coverage for all Gemini provider modules**

- [ ] **Task 6.2: Integration Tests** (AC-4)
  - [ ] **MANDATORY: Provider integration testing**
  - [ ] **Generic interface integration tests**
  - [ ] **Streaming integration tests with existing handler**
  - [ ] **Cross-provider compatibility tests**
  - [ ] **Validation: All integration tests pass consistently**

- [ ] **Task 6.3: E2E Testing Script** (AC-4)
  - [ ] **MANDATORY: Create comprehensive E2E test script**
  - [ ] **Script:** `scripts/test_full_gemini_oauth_streaming_e2e.exs`
  - [ ] **E2E test coverage:**
    ```elixir
    # Test flow:
    # 1. OAuth flow: Generate URL → manual auth → token exchange
    # 2. API Key flow: Direct session creation with API key
    # 3. Model listing for both authentication modes
    # 4. Streaming chat with Gemini models
    # 5. Token refresh validation (OAuth mode)
    # 6. Session cleanup and deletion
    ```
  - [ ] **Real Gemini API integration testing**
  - [ ] **Both OAuth and API key authentication workflows**
  - [ ] **Validation: E2E test covers complete authentication → streaming → cleanup flow**

- [ ] **Task 6.4: Manual Testing Protocol** (AC-4)
  - [ ] **MANDATORY: Manual testing checklist**
  - [ ] **Manual OAuth flow testing:**
    1. Start OAuth flow and follow authorization URL
    2. Complete Google OAuth and receive authorization code
    3. Verify automatic token exchange and session creation
    4. Test streaming chat with Gemini 2.5 Pro model
    5. Verify token refresh works automatically
    6. Test session cleanup and deletion
  - [ ] **API key flow testing:**
    1. Create session with Google AI Studio API key
    2. Test model listing and selection
    3. Test streaming chat with different Gemini models
    4. Verify session management and cleanup
  - [ ] **Error scenario testing (network failures, invalid tokens, etc.)**
  - [ ] **Validation: Manual testing protocol covers all critical user paths**

## Dev Notes

### Architecture Context

This story implements the complete Gemini provider using the universal provider architecture established in Story 0.1. The key requirement is to research and adapt patterns from the existing `gemini-cli` implementation at `/Users/jasonk/Development/the_maestro/source/gemini-cli` to ensure compatibility with Google's OAuth and API patterns.

### Technical Implementation Details

#### 1. Research Phase - gemini-cli Analysis
The implementation must start with thorough analysis of the existing `gemini-cli` OAuth implementation to understand Google's authentication patterns:

**Key Research Files:**
```
/Users/jasonk/Development/the_maestro/source/gemini-cli/
├── packages/core/src/code_assist/oauth2.ts        # Main OAuth implementation
├── packages/core/src/mcp/google-auth-provider.ts  # Google Auth patterns  
├── packages/core/src/mcp/oauth-utils.ts           # OAuth utilities
├── packages/core/src/mcp/oauth-token-storage.ts   # Token management
└── README.md                                      # Usage patterns and setup
```

#### 2. Provider Module Structure
Following the universal provider pattern from Story 0.1, create the complete Gemini provider module structure with proper behavior implementations.

#### 3. Google OAuth 2.0 Implementation
Based on gemini-cli patterns, implement Google OAuth 2.0 with PKCE:

```elixir
defmodule TheMaestro.Providers.Gemini.OAuth do
  @behaviour TheMaestro.Provider.OAuth
  
  # Google OAuth 2.0 configuration (following gemini-cli patterns)
  @oauth_client_id "YOUR_GOOGLE_CLIENT_ID"
  @oauth_client_secret "YOUR_GOOGLE_CLIENT_SECRET"
  @oauth_scopes [
    "https://www.googleapis.com/auth/cloud-platform",
    "https://www.googleapis.com/auth/userinfo.email",
    "https://www.googleapis.com/auth/userinfo.profile",
    "https://www.googleapis.com/auth/generative-language.retriever"
  ]
  
  def generate_auth_url(session_id, opts) do
    %{code_verifier: code_verifier, code_challenge: code_challenge} = generate_pkce()
    
    # Store PKCE verifier for later token exchange
    store_pkce_verifier(session_id, code_verifier)
    
    params = %{
      client_id: @oauth_client_id,
      redirect_uri: redirect_uri(),
      response_type: "code",
      scope: Enum.join(@oauth_scopes, " "),
      state: generate_state(),
      code_challenge: code_challenge,
      code_challenge_method: "S256",
      access_type: "offline",
      prompt: "consent"
    }
    
    url = "https://accounts.google.com/oauth2/auth?" <> URI.encode_query(params)
    {:ok, url}
  end
end
```

#### 4. API Key Implementation
Support Google AI Studio API keys for simpler authentication:

```elixir
defmodule TheMaestro.Providers.Gemini.ApiKey do
  @behaviour TheMaestro.Provider.ApiKey
  
  def create_session(api_key, opts) do
    # Validate API key with Gemini API
    case validate_api_key(api_key) do
      {:ok, _response} ->
        session_id = generate_session_id()
        store_api_key(session_id, api_key)
        {:ok, session_id}
      {:error, reason} ->
        {:error, "Invalid API key: #{reason}"}
    end
  end
  
  defp validate_api_key(api_key) do
    Req.get(
      url: "https://generativelanguage.googleapis.com/v1/models",
      headers: [{"x-goog-api-key", api_key}]
    )
  end
end
```

#### 5. Streaming Integration
Integrate with the existing `TheMaestro.Streaming.GeminiHandler` through the universal streaming interface:

```elixir
defmodule TheMaestro.Providers.Gemini.Streaming do
  @behaviour TheMaestro.Provider.Streaming
  
  def stream_chat(session_id, messages, opts) do
    with {:ok, auth_headers} <- get_auth_headers(session_id),
         {:ok, stream} <- create_gemini_stream(auth_headers, messages, opts) do
      
      # Feed stream through universal parser with Gemini handler
      parsed_stream = TheMaestro.Streaming.parse_stream(
        stream, 
        :gemini, 
        opts
      )
      
      {:ok, parsed_stream}
    end
  end
  
  defp get_auth_headers(session_id) do
    case get_session_type(session_id) do
      {:oauth, tokens} ->
        {:ok, [{"authorization", "Bearer #{tokens.access_token}"}]}
      {:api_key, api_key} ->
        {:ok, [{"x-goog-api-key", api_key}]}
      {:error, reason} ->
        {:error, reason}
    end
  end
  
  defp create_gemini_stream(auth_headers, messages, opts) do
    model = opts[:model] || "models/gemini-2.5-pro"
    
    headers = [
      {"content-type", "application/json"} | auth_headers
    ]
    
    payload = %{
      model: model,
      contents: format_messages(messages),
      stream: true,
      generationConfig: %{
        maxOutputTokens: opts[:max_tokens] || 8192,
        temperature: opts[:temperature] || 0.7
      }
    }
    
    Req.post(
      url: "https://generativelanguage.googleapis.com/v1/#{model}:streamGenerateContent",
      json: payload,
      headers: headers,
      into: :stream
    )
  end
end
```

#### 6. Model Information
Support current Gemini model families with proper information:

```elixir
defmodule TheMaestro.Providers.Gemini.Models do
  @behaviour TheMaestro.Provider.Models
  
  @gemini_models [
    %{
      id: "models/gemini-2.5-pro",
      name: "Gemini 2.5 Pro", 
      description: "Most capable model with enhanced thinking and reasoning",
      context_window: 1_048_576,
      max_tokens: 65_536,
      input_cost_per_mtok: 1.25,
      output_cost_per_mtok: 5.00
    },
    %{
      id: "models/gemini-2.5-flash",
      name: "Gemini 2.5 Flash",
      description: "Best price-performance model with adaptive thinking", 
      context_window: 1_048_576,
      max_tokens: 65_536,
      input_cost_per_mtok: 0.075,
      output_cost_per_mtok: 0.30
    },
    %{
      id: "models/gemini-2.0-flash",
      name: "Gemini 2.0 Flash",
      description: "Next-gen features with speed and real-time streaming",
      context_window: 1_048_576,
      max_tokens: 8_192,
      input_cost_per_mtok: 0.15,
      output_cost_per_mtok: 0.60
    }
  ]
  
  def list_models(session_id, opts) do
    with {:ok, auth_headers} <- get_auth_headers(session_id),
         {:ok, response} <- fetch_live_models(auth_headers) do
      
      # Merge static model info with live API response
      models = merge_model_info(@gemini_models, response.body["models"])
      {:ok, models}
    end
  end
  
  defp fetch_live_models(auth_headers) do
    Req.get(
      url: "https://generativelanguage.googleapis.com/v1/models",
      headers: [{"content-type", "application/json"} | auth_headers]
    )
  end
end
```

### Migration Strategy

#### Phase 1: Research and Analysis (1 day)
1. Comprehensive analysis of `gemini-cli` OAuth implementation
2. Extract Google OAuth patterns and API key usage
3. Document authentication flow requirements

#### Phase 2: Module Creation and Basic Structure (2 days)
1. Create provider directory structure
2. Implement basic behavior modules with Google OAuth patterns
3. Register provider with universal interface

#### Phase 3: OAuth Implementation (2.5 days)
1. Implement Google OAuth 2.0 with PKCE based on gemini-cli patterns
2. Add token exchange and refresh functionality
3. Integrate with background worker for automatic refresh

#### Phase 4: API Key and Streaming Integration (2 days)
1. Implement API key authentication mode
2. Integrate with existing `GeminiHandler` for streaming
3. Add model listing with live API integration

#### Phase 5: Testing and Validation (2.5 days)
1. Comprehensive unit and integration testing
2. E2E testing script with both authentication modes
3. Manual testing protocol verification

### Security Considerations

#### 1. Google OAuth PKCE Implementation
Proper PKCE (Proof Key for Code Exchange) implementation for OAuth security:
- Generate cryptographically secure code verifier
- Create SHA256 code challenge  
- Securely store verifier for token exchange
- Clean up verifier after successful token exchange

#### 2. Token Security
- Secure token storage using encrypted sessions
- Automatic token rotation on refresh
- Proper token cleanup on session deletion
- Access token expiration handling

#### 3. API Key Security
- Secure API key storage and transmission
- API key validation before use
- Proper cleanup on session deletion

### Integration Points

#### 1. Existing Gemini Infrastructure
- `TheMaestro.Streaming.GeminiHandler` - Reuse existing streaming handler
- Background refresh worker - Integrate with existing token refresh system
- Named sessions schema from Story 0.1

#### 2. Universal Provider Interface
- `TheMaestro.Provider` - All operations must go through generic interface
- `TheMaestro.Sessions` - Named session storage and management
- `TheMaestro.Streaming` - Universal streaming with `parse_stream/3`

#### 3. gemini-cli Reference Implementation
- OAuth patterns and configuration
- Google client setup and scoping
- PKCE implementation and token management
- API key usage patterns

### Performance Considerations

#### 1. Streaming Efficiency
- Reuse existing `GeminiHandler` for optimal performance
- Minimize overhead in universal streaming adapter
- Proper backpressure handling in Req streaming

#### 2. Token Management
- Efficient token storage and retrieval
- Background refresh to prevent token expiration
- Connection pooling for Gemini API calls

#### 3. Session Management
- Efficient named session lookup
- Proper session cleanup and garbage collection
- Memory-efficient credential storage

### Testing Strategy

#### 1. Unit Testing
Complete unit test coverage for all provider modules with mocked Google OAuth and Gemini API responses.

#### 2. Integration Testing
Test integration with universal provider interface and existing streaming infrastructure.

#### 3. E2E Testing  
Comprehensive end-to-end testing with real Gemini API for all auth types:
- OAuth (personal account): PKCE → stream standardized prompt; validate headers and full response via universal parser
- Personal API key: create session → stream standardized prompt; validate `X-Goog-Api-Key` and full response
- Enterprise API key: create session with optional `X-Goog-User-Project` → stream standardized prompt; validate headers and full response

#### 4. Performance Testing
Benchmark against existing Gemini usage to ensure no performance regression.

### Quality Gates

#### 1. Code Quality
- All provider modules implement required behaviors
- >90% test coverage across all modules
- Proper error handling and edge case coverage

#### 2. Security Validation
- Google OAuth PKCE implementation security review
- Token and API key security validation  
- OAuth flow security assessment

#### 3. Integration Validation
- Universal provider interface compliance
- Streaming integration with existing handler
- Named sessions functionality verification

#### 4. Performance Validation
- Streaming performance matches existing implementation
- Token refresh performance is acceptable
- Memory usage within acceptable limits

### gemini-cli Research Requirements

#### 1. OAuth Implementation Analysis
**MANDATORY Research Tasks:**
- Analyze `packages/core/src/code_assist/oauth2.ts` for Google OAuth patterns
- Extract PKCE implementation details and security measures
- Understand token exchange flow and refresh mechanisms
- Document Google client configuration requirements

#### 2. API Key Implementation Analysis  
**MANDATORY Research Tasks:**
- Analyze API key authentication patterns from gemini-cli
- Understand Google AI Studio API key integration
- Extract authentication header formats and validation methods
- Document API key session management patterns

#### 3. Integration Pattern Analysis
**MANDATORY Research Tasks:**
- Understand how gemini-cli integrates with Google APIs
- Extract endpoint URLs, scopes, and configuration patterns
- Analyze error handling and recovery mechanisms
- Document best practices and security considerations

## Change Log
- **2025-08-30**: Initial story creation for Epic 0 Gemini provider implementation
- **2025-09-01**: Implemented Gemini API key + OAuth sessions, header injection for GEMINI/GOOGLE_API_KEY and OAuth Bearer, streaming via Req SSE, models listing endpoints; added helper functions for OAuth URL generation and finishing flow

## QA Results
_Pending - Will be updated during implementation and testing phases_

### Test Coverage Goals
- **Unit Tests**: >90% coverage for all provider modules
- **Integration Tests**: 100% coverage for universal provider interface methods  
- **E2E Tests**: Complete OAuth + API key → streaming → cleanup flow validation

### Performance Benchmarks
- **Streaming Latency**: Match or exceed existing implementation
- **Token Refresh Time**: <3 seconds for background refresh
- **Session Creation**: <500ms for both OAuth and API key modes

### Security Validation
- **OAuth Security**: Google OAuth PKCE implementation validated by security review
- **Token Security**: Encrypted storage and proper cleanup validated
- **API Key Security**: Secure API key handling and validation confirmed
- **Session Isolation**: Named sessions properly isolated and secure

### gemini-cli Integration Validation
- **Pattern Compliance**: Implementation follows gemini-cli OAuth patterns
- **Google API Compatibility**: Works with same Google OAuth endpoints as gemini-cli
- **Security Standards**: Matches gemini-cli security implementation standards
